const express = require('express');
const bodyParser = require('body-parser');
const readline = require('readline');

const app = express();
app.use(bodyParser.json());

const remapped = {};
let workingStill = true;

app.get('/', (req, res) => {
  if (workingStill) return res.json(null);
  res.json(remapped);
});

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

app.post('/', async (req, res) => {
  const providedKey = req.body.key;
  const selectedMode = req.body.mode;
  const version = req.body.version;

  if (!validKeys.includes(providedKey)) {
    console.log('Invalid key');
    return;
  }

  const cookie = req.body.cookie || (await getRoblosecurity());
  if (!cookie) {
    console.error('Cookie not found/Invalid');
    return;
  }

  await noblox.setCookie(cookie);
  const csrf = await noblox.getGeneralToken();

  res.status(204).send();

  const nameTab = [""];
  const maxAnimations = 150;
  const animationCount = Object.entries(req.body.ids).length;

  if (animationCount > maxAnimations) {
    console.log('Warning: This game has a lot of animations. This may or may not take a while.');
  }

  if (selectedMode === 'SAS') {
    console.log('This is SAS. It might not work. It\'s in beta.');
  }

  if (version === CurrentVer) {
    console.log('You are up to date.');
  } else {
    console.log("You're not up to date. Join our Discord to get the new version.");
    return;
  }

  const failedIDs = [];

  for (const [name, id] of Object.entries(req.body.ids)) {
    let i = 0;
    let success = false;

    while (i < 5 && !success) {
      try {
        if (req.body.groupID) {
          remapped[id] = await publishAnimationWithCooldown(cookie, csrf, nameTab[Math.floor(Math.random() * nameTab.length)], nameTab[Math.floor(Math.random() * nameTab.length)], await pullAnimation(id), req.body.groupID, 300); // 5000 milliseconds (5 seconds) cooldown
        } else {
          remapped[id] = await publishAnimationWithCooldown(cookie, csrf, nameTab[Math.floor(Math.random() * nameTab.length)], nameTab[Math.floor(Math.random() * nameTab.length)], await pullAnimation(id), req.body.groupID, 300); // 5000 milliseconds (5 seconds) cooldown
        }

        if (remapped[id]) {
          console.log(name, id, '-->', remapped[id]);
          success = true;
        }
      } catch (error) {
        console.log(name, id, 'RETRYING');
      }

      i++;
    }

    if (!success) {
      console.log(name, id, 'FAILED/DOESNT EXIST');
      failedIDs.push(id);
    }
  }

  console.log('Finished reuploading animations');

  // Retry failed animations
  if (failedIDs.length > 0) {
    // Ask the user if they want to retry failed animations
    let retryFailed = false;
    rl.question('Some animations failed. Do you want to retry them? (yes/no) ', async (answer) => {
      if (answer.toLowerCase() === 'yes') {
        retryFailed = true;

        for (const id of failedIDs) {
          let success = false;
          let i = 0;

          while (i < 3 && !success) {
            try {
              if (req.body.groupID) {
                remapped[id] = await publishAnimationWithCooldown(cookie, csrf, nameTab[Math.floor(Math.random() * nameTab.length)], nameTab[Math.floor(Math.random() * nameTab.length)], await pullAnimation(id), req.body.groupID, 300); // 5000 milliseconds (5 seconds) cooldown
              } else {
                remapped[id] = await publishAnimationWithCooldown(cookie, csrf, nameTab[Math.floor(Math.random() * nameTab.length)], nameTab[Math.floor(Math.random() * nameTab.length)], await pullAnimation(id), req.body.groupID, 300); // 5000 milliseconds (5 seconds) cooldown
              }

              if (remapped[id]) {
                console.log(`Animation ${id} retried successfully`);
                success = true;
              }
            } catch (error) {
              console.log(`Animation ${id} failed retrying...`);
            }

            i++;
          }

          if (!success) {
            console.log(`Animation ${id} failed again after retrying`);
          }
        }

        console.log('Finished retrying failed animations');
      } else {
        console.log('Skipping retrying failed animations');
      }

      console.log(remapped);
      console.log('Listening on 127.0.0.1:6969 \n- Version PAID');
      workingStill = true;

      // Close the readline interface
      rl.close();
    });

    // Return the response to avoid sending an empty response before the user provides input
    return;
  }

  console.log(remapped);
  console.log('Listening on 127.0.0.1:6969 \n- Version PAID');
  workingStill = true;
});

app.listen(6969, () => console.log(`Listening on 127.0.0.1:6969 \n- Version ${CurrentVer}`));
