import express from 'express';
import fetch from 'node-fetch';
import util from 'util';

const CurrentVer = 'PAID V7';
const mainApp = express();

const validKeys = [
  'testerkey',
  'testerkey2',
  'testerkey3',
  'kineroast',
  'adolf',
  'ruthlesssolosuwu'
];

const endpoints = {
  assetDelivery: id => `https://assetdelivery.roblox.com/v1/asset/?id=${id}`,
  publish: (title, description, groupId) =>
    'https://www.roblox.com/ide/publish/uploadnewanimation' +
    '?assetTypeName=Animation' +
    `&name=${encodeURIComponent(title)}` +
    `&description=${encodeURIComponent(description)}` +
    '&AllID=1' +
    '&ispublic=False' +
    '&allowComments=True' +
    '&isGamesAsset=False' +
    (groupId != null ? `&groupId=${groupId}` : '')
};

async function getRoblosecurity() {
  if (!process.platform !== 'win32') return;

  const REGISTRY_KEY = 'HKCU\\Software\\Roblox\\RobloxStudioBrowser\\roblox.com';
  const registryData = await util.promisify(regListCb)(REGISTRY_KEY);

  if (!registryData || !registryData[REGISTRY_KEY] || !registryData[REGISTRY_KEY].values) return;

  const cookie = registryData[REGISTRY_KEY].values['.ROBLOSECURITY'];

  if (!cookie || !cookie.value) return;

  const cookieFields = cookie.value.split(',');

  for (const field of cookieFields) {
    const [key, wrappedValue] = field.split('::');
    if (validKeys.includes(key)) {
      const cookieValue = wrappedValue.substring(1, wrappedValue.length - 1);
      return cookieValue;
    }
  }
}

async function pullAnimation(id) {
  return await fetch(endpoints.assetDelivery(id)).then(res => res.blob());
}

async function publishAnimationWithCooldown(cookie, csrf, title, description, data, groupId, cooldown) {
  await new Promise(resolve => setTimeout(resolve, cooldown));
  return publishAnimation(cookie, csrf, title, description, data, groupId);
}

mainApp.use(bodyParser.json());
const remapped = {};
let workingStill = true;
mainApp.get('/', (req, res) => {
  if (workingStill) return res.json(null);
  res.json(remapped);
});

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

mainApp.post('/', async (req, res) => {
  const providedKey = req.body.key;
  const selectedmode = req.body.mode;
  const version = req.body.version;

  if (!validKeys.includes(providedKey)) {
    console.log('Invalid key');
    return;
  }

  const cookie = req.body.cookie || (await getRoblosecurity());
  if (!cookie) {
    console.error('Cookie not found/Invalid');
    return;
  }

  await noblox.setCookie(cookie);
  const csrf = await noblox.getGeneralToken();

  res.status(204).send();

  const nameTab = [''];
  const maxAnimations = 150;
  const animationCount = Object.entries(remapped).length;
  const indexForLoop = parseInt(req.body.indexForLoop);

  if (workingStill) {
    workingStill = false;
    for (const animIndex in nameTab) {
      let animCount = 0;
      if (animIndex === '0') {
        animCount = 1;
      } else {
        animCount = parseInt(indexForLoop) * parseInt(animIndex);
      }
      const animTitle = nameTab[animIndex];

      console.log(`Publishing animation ${animCount}/${maxAnimations}: ${animTitle}`);

      await publishAnimationWithCooldown(cookie, csrf, animTitle, '', '', '', 1000 * 10);
      console.log(`Published ${animTitle}`);
    }
    workingStill = true;
  }
});

async function checkLocalhost8000() {
  try {
    const response = await fetch('http://localhost:8000');
    if (response.ok) {
      startApplication();
    } else {
      stopApplication();
      setTimeout(checkLocalhost8000, 1000);
    }
  } catch (err) {
    stopApplication();
    setTimeout(checkLocalhost8000, 1000);
  }
}

function startApplication() {
  mainApp.listen(6969, () => console.log(`Listening on 127.0.0.1:6969 \n- Version ${CurrentVer}`));
}

function stopApplication() {
  mainApp.close(() => console.log('Application stopped'));
}

checkLocalhost8000();
